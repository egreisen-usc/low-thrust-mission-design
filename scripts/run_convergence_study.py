#!/usr/bin/env python3
"""
Convergence Study Runner
Validates that orbital element propagation converges with timestep refinement

Usage:
    python3 scripts/run_convergence_study.py
    
This script:
1. Runs the propagator with multiple timesteps (10000, 5000, 2000, 1000 s)
2. Extracts final orbital elements from each run's CSV
3. Computes relative errors vs the finest timestep
4. Generates diagnostic plots showing convergence behavior
5. Saves results to convergence_study/ directory
"""

import subprocess
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
import yaml
import sys
import shutil
import os
import time

# Configuration
TIMESTEPS = [10000, 5000, 2000, 1000]  # seconds
EXECUTABLE = "./build/bin/propagate_trajectory"
CONFIG_FILE = "config/convergence_test.yaml"
STUDY_DIR = Path("convergence_study")
RESULTS_DIR = STUDY_DIR / "results"
PLOTS_DIR = STUDY_DIR / "plots"

# Create directories
RESULTS_DIR.mkdir(parents=True, exist_ok=True)
PLOTS_DIR.mkdir(parents=True, exist_ok=True)

print("="*70)
print("CONVERGENCE STUDY: Timestep Independence Validation")
print("="*70)

# Store results for analysis
convergence_data = {}

# ─────────────────────────────────────────────────────────────────────────
# PHASE 1: Run propagator for each timestep
# ─────────────────────────────────────────────────────────────────────────

for dt in TIMESTEPS:
    print(f"\n{'─'*70}")
    print(f"Running propagator with Δt = {dt:,} s")
    print(f"{'─'*70}")
    
    # Create subdirectory for this timestep
    dt_dir = RESULTS_DIR / f"timestep_{dt}"
    dt_dir.mkdir(exist_ok=True)
    
    # Read baseline config
    if not Path(CONFIG_FILE).exists():
        print(f"❌ ERROR: Config file not found: {CONFIG_FILE}")
        print(f"   Please create config/convergence_test.yaml first")
        sys.exit(1)
    
    with open(CONFIG_FILE, 'r') as f:
        config = yaml.safe_load(f)
    
    # Override timestep
    config['integration']['timestep'] = dt
    
    # Write modified config to temp file
    temp_config = dt_dir / "config_modified.yaml"
    with open(temp_config, 'w') as f:
        yaml.dump(config, f)
    
    # Run propagator with timestep override
    # Command: ./build/bin/propagate_trajectory config_file --timestep value
    cmd = [EXECUTABLE, str(temp_config), "--timestep", str(dt)]
    
    print(f"Command: {' '.join(cmd)}")
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=300
        )
        
        if result.returncode != 0:
            print(f"❌ ERROR: Propagator failed (exit code {result.returncode})")
            if result.stderr:
                print(f"   stderr: {result.stderr[:500]}")
            continue
        
        print(f"✓ Propagator completed successfully")
        
        # Find trajectory CSV files generated by the propagator
        # The propagator writes based on the config (destination + thruster_type)
        # Look for all *trajectory.csv files in results/
        csv_files = list(Path("results").glob("*trajectory.csv"))
        
        if not csv_files:
            print(f"❌ ERROR: No CSV output found in results/")
            print(f"   Expected pattern: *trajectory.csv")
            continue
        
        # Copy ALL trajectory CSVs to this timestep's directory
        # (in case there are multiple - we want all of them)
        for csv_file in csv_files:
            output_csv = dt_dir / csv_file.name
            shutil.copy(csv_file, output_csv)
            print(f"✓ Copied: {csv_file.name}")
            
            # Parse CSV and extract final state from FIRST/MAIN trajectory file
            # (If multiple, we'll use the first one)
            if csv_file == csv_files[0]:
                try:
                    df = pd.read_csv(output_csv)
                except Exception as e:
                    print(f"❌ ERROR: Could not parse CSV: {e}")
                    continue
                
                final_row = df.iloc[-1]
                
                # Map column names from actual CSV to standardized names
                # Your CSV has: time(s), a(km), e, ra(km), rp(km), m(kg), etc.
                col_map = {
                    'time(s)': 'time',
                    'a(km)': 'semi_major_axis',
                    'e': 'eccentricity',
                    'rp(km)': 'periapsis',
                    'ra(km)': 'apoapsis',
                    'm(kg)': 'mass'
                }
                
                # Extract values using actual column names
                convergence_data[dt] = {
                    'steps': len(df),
                    'time': final_row.get('time(s)', np.nan),
                    'a': final_row.get('a(km)', np.nan),
                    'e': final_row.get('e', np.nan),
                    'r_p': final_row.get('rp(km)', np.nan),
                    'r_a': final_row.get('ra(km)', np.nan),
                    'delta_v': np.nan,  # Not in CSV
                    'fuel': final_row.get('m(kg)', np.nan),
                    'csv_file': str(output_csv)
                }
                
                print(f"\n   Final orbital elements:")
                print(f"   a  = {convergence_data[dt]['a']:>15.2f} km")
                print(f"   e  = {convergence_data[dt]['e']:>15.8f}")
                print(f"   r_p = {convergence_data[dt]['r_p']:>14.2f} km")
                print(f"   r_a = {convergence_data[dt]['r_a']:>14.2f} km")
                print(f"   m  = {convergence_data[dt]['fuel']:>15.2f} kg")
                print(f"   Steps: {convergence_data[dt]['steps']:>11}")
            
    except subprocess.TimeoutExpired:
        print(f"❌ ERROR: Propagator timeout (>300s)")
    except Exception as e:
        print(f"❌ ERROR: {e}")

if not convergence_data:
    print("\n" + "="*70)
    print("❌ No convergence data collected. Exiting.")
    print("="*70)
    sys.exit(1)

# ─────────────────────────────────────────────────────────────────────────
# PHASE 2: Compute errors and convergence metrics
# ─────────────────────────────────────────────────────────────────────────

print(f"\n{'='*70}")
print("CONVERGENCE ANALYSIS")
print(f"{'='*70}")

# Reference (finest timestep)
dt_ref = TIMESTEPS[-1]

# Check for NaN values
valid_timesteps = [dt for dt in convergence_data if not np.isnan(convergence_data[dt]['a'])]
if not valid_timesteps:
    print("❌ No valid data for analysis")
    sys.exit(1)

dt_ref = max(valid_timesteps)  # Use finest valid timestep
a_ref = convergence_data[dt_ref]['a']
e_ref = convergence_data[dt_ref]['e']
rp_ref = convergence_data[dt_ref]['r_p']
ra_ref = convergence_data[dt_ref]['r_a']

print(f"\nReference solution (Δt = {dt_ref:,} s):")
print(f"  a   = {a_ref:>15.2f} km")
print(f"  e   = {e_ref:>15.8f}")
print(f"  r_p = {rp_ref:>15.2f} km")
print(f"  r_a = {ra_ref:>15.2f} km")

# Compute relative errors
error_data = {}
print(f"\nRelative errors (vs Δt = {dt_ref:,} s):")
print(f"{'Δt (s)':>10} | {'Δa (%)':>12} | {'Δe (%)':>12} | {'Δrp (%)':>12}")
print("─" * 62)

for i, dt in enumerate(sorted(valid_timesteps)):
    error_a = abs(convergence_data[dt]['a'] - a_ref) / a_ref * 100
    error_e = abs(convergence_data[dt]['e'] - e_ref) / abs(e_ref) * 100 if e_ref != 0 else 0
    error_rp = abs(convergence_data[dt]['r_p'] - rp_ref) / rp_ref * 100 if rp_ref != 0 else 0
    
    error_data[dt] = {'a': error_a, 'e': error_e, 'rp': error_rp}
    
    print(f"{dt:>10} | {error_a:>12.6f} | {error_e:>12.6f} | {error_rp:>12.6f}")

# Compute convergence order
print(f"\nConvergence order (log-log slope):")
print(f"{'Δt ratio':>15} | {'a order':>12} | {'e order':>12} | {'rp order':>12}")
print("─" * 62)

sorted_dts = sorted(valid_timesteps)
for i in range(1, len(sorted_dts)):
    dt_prev = sorted_dts[i-1]
    dt_curr = sorted_dts[i]
    
    err_a_prev = error_data[dt_prev]['a']
    err_a_curr = error_data[dt_curr]['a']
    err_e_prev = error_data[dt_prev]['e']
    err_e_curr = error_data[dt_curr]['e']
    err_rp_prev = error_data[dt_prev]['rp']
    err_rp_curr = error_data[dt_curr]['rp']
    
    if err_a_prev > 1e-6 and err_a_curr > 1e-6:
        order_a = np.log(err_a_prev / err_a_curr) / np.log(dt_prev / dt_curr)
    else:
        order_a = np.nan
    
    if err_e_prev > 1e-6 and err_e_curr > 1e-6:
        order_e = np.log(err_e_prev / err_e_curr) / np.log(dt_prev / dt_curr)
    else:
        order_e = np.nan
    
    if err_rp_prev > 1e-6 and err_rp_curr > 1e-6:
        order_rp = np.log(err_rp_prev / err_rp_curr) / np.log(dt_prev / dt_curr)
    else:
        order_rp = np.nan
    
    ratio = dt_prev / dt_curr
    print(f"{ratio:>15.1f} | {order_a:>12.2f} | {order_e:>12.2f} | {order_rp:>12.2f}")

# Save summary
summary_df = pd.DataFrame(convergence_data).T
summary_df.to_csv(RESULTS_DIR / "convergence_summary.csv")
print(f"\n✓ Summary saved: convergence_study/results/convergence_summary.csv")

# ─────────────────────────────────────────────────────────────────────────
# PHASE 3: Generate diagnostic plots
# ─────────────────────────────────────────────────────────────────────────

print(f"\nGenerating diagnostic plots...")

dt_array = np.array(sorted(valid_timesteps))
a_array = np.array([convergence_data[dt]['a'] for dt in dt_array])
e_array = np.array([convergence_data[dt]['e'] for dt in dt_array])
rp_array = np.array([convergence_data[dt]['r_p'] for dt in dt_array])
ra_array = np.array([convergence_data[dt]['r_a'] for dt in dt_array])

# Figure 1: Orbital Elements Convergence
fig, axes = plt.subplots(2, 2, figsize=(13, 10))
fig.suptitle('Orbital Elements: Convergence with Timestep Refinement', 
             fontsize=14, fontweight='bold', y=0.995)

# Semi-major axis
ax = axes[0, 0]
ax.semilogx(dt_array, a_array, 'o-', linewidth=2.5, markersize=9, color='#1f77b4', label='RK4')
ax.set_xlabel('Timestep Δt (s)', fontsize=11, fontweight='bold')
ax.set_ylabel('Semi-major axis a (km)', fontsize=11, fontweight='bold')
ax.set_title('Semi-major Axis vs Timestep', fontsize=12, fontweight='bold')
ax.grid(True, alpha=0.3, linestyle='--')
ax.set_axisbelow(True)

# Eccentricity
ax = axes[0, 1]
ax.semilogx(dt_array, e_array, 's-', linewidth=2.5, markersize=9, color='#ff7f0e', label='RK4')
ax.set_xlabel('Timestep Δt (s)', fontsize=11, fontweight='bold')
ax.set_ylabel('Eccentricity e', fontsize=11, fontweight='bold')
ax.set_title('Eccentricity vs Timestep', fontsize=12, fontweight='bold')
ax.grid(True, alpha=0.3, linestyle='--')
ax.set_axisbelow(True)

# Periapsis
ax = axes[1, 0]
ax.semilogx(dt_array, rp_array, '^-', linewidth=2.5, markersize=9, color='#2ca02c', label='RK4')
ax.set_xlabel('Timestep Δt (s)', fontsize=11, fontweight='bold')
ax.set_ylabel('Periapsis r_p (km)', fontsize=11, fontweight='bold')
ax.set_title('Periapsis vs Timestep', fontsize=12, fontweight='bold')
ax.grid(True, alpha=0.3, linestyle='--')
ax.set_axisbelow(True)

# Apoapsis
ax = axes[1, 1]
ax.semilogx(dt_array, ra_array, 'D-', linewidth=2.5, markersize=9, color='#d62728', label='RK4')
ax.set_xlabel('Timestep Δt (s)', fontsize=11, fontweight='bold')
ax.set_ylabel('Apoapsis r_a (km)', fontsize=11, fontweight='bold')
ax.set_title('Apoapsis vs Timestep', fontsize=12, fontweight='bold')
ax.grid(True, alpha=0.3, linestyle='--')
ax.set_axisbelow(True)

plt.tight_layout()
plt.savefig(PLOTS_DIR / 'convergence_orbital_elements.png', dpi=300, bbox_inches='tight')
print(f"✓ Saved: convergence_orbital_elements.png")
plt.close()

# Figure 2: Relative Error vs Timestep (Convergence Rate)
fig, ax = plt.subplots(figsize=(12, 7))

error_a_array = np.array([error_data[dt]['a'] for dt in dt_array])
error_e_array = np.array([error_data[dt]['e'] for dt in dt_array])
error_rp_array = np.array([error_data[dt]['rp'] for dt in dt_array])

# Plot errors (exclude finest, which has zero error)
dt_plot = dt_array[:-1]
error_a_plot = error_a_array[:-1]
error_e_plot = error_e_array[:-1]
error_rp_plot = error_rp_array[:-1]

ax.loglog(dt_plot, error_a_plot, 'o-', linewidth=2.5, markersize=10, label='Semi-major axis', color='#1f77b4')
ax.loglog(dt_plot, error_e_plot, 's-', linewidth=2.5, markersize=10, label='Eccentricity', color='#ff7f0e')
ax.loglog(dt_plot, error_rp_plot, '^-', linewidth=2.5, markersize=10, label='Periapsis', color='#2ca02c')

# Add reference convergence rate lines
if len(dt_plot) >= 2:
    dt_min, dt_max = dt_plot[0], dt_plot[-1]
    err_max = max(error_a_plot[-1], error_e_plot[-1], error_rp_plot[-1])
    
    x_ref = np.logspace(np.log10(dt_min), np.log10(dt_max), 50)
    
    # O(Δt) line (first-order)
    y_linear = err_max * (x_ref / dt_max)**1
    ax.loglog(x_ref, y_linear, 'k--', alpha=0.4, linewidth=1.5, label='O(Δt) reference')
    
    # O(Δt²) line (second-order)
    y_quad = err_max * (x_ref / dt_max)**2
    ax.loglog(x_ref, y_quad, 'k:', alpha=0.4, linewidth=1.5, label='O(Δt²) reference')
    
    # O(Δt⁴) line (fourth-order, expected for RK4)
    y_quart = err_max * (x_ref / dt_max)**4
    ax.loglog(x_ref, y_quart, 'k-.', alpha=0.4, linewidth=1.5, label='O(Δt⁴) reference')

ax.set_xlabel('Timestep Δt (s)', fontsize=12, fontweight='bold')
ax.set_ylabel('Relative Error (%)', fontsize=12, fontweight='bold')
ax.set_title('Convergence Rate Analysis: Error vs Timestep', fontsize=13, fontweight='bold')
ax.legend(fontsize=10, loc='upper left', framealpha=0.95)
ax.grid(True, which='both', alpha=0.3, linestyle='--')
ax.set_axisbelow(True)

plt.tight_layout()
plt.savefig(PLOTS_DIR / 'convergence_rate.png', dpi=300, bbox_inches='tight')
print(f"✓ Saved: convergence_rate.png")
plt.close()

# ─────────────────────────────────────────────────────────────────────────
# PHASE 4: Summary and Interpretation
# ─────────────────────────────────────────────────────────────────────────

print(f"\n{'='*70}")
print("CONVERGENCE STUDY COMPLETE")
print(f"{'='*70}")
print(f"\nResults saved to: {STUDY_DIR}/")
print(f"  • Trajectory CSVs: results/timestep_*/")
print(f"  • Summary table: results/convergence_summary.csv")
print(f"  • Diagnostic plots: plots/")

# Interpretation
print(f"\nINTERPRETATION:")
print(f"{'─'*70}")

dt_coarse = min(valid_timesteps)
error_coarse_a = error_data[dt_coarse]['a']

if error_coarse_a < 0.1:
    status = "✓ EXCELLENT"
    msg = f"Error at Δt = {dt_coarse:,}s is < 0.1%"
    rec = "Current timestep is MORE than adequate. Could potentially use coarser timesteps for efficiency."
elif error_coarse_a < 1.0:
    status = "✓ GOOD"
    msg = f"Error at Δt = {dt_coarse:,}s is < 1.0%"
    rec = "Current timestep is appropriate. Results are numerically converged."
elif error_coarse_a < 5.0:
    status = "⚠ ACCEPTABLE"
    msg = f"Error at Δt = {dt_coarse:,}s is < 5.0%"
    rec = "Consider refining timestep for higher accuracy."
else:
    status = "⚠ WARNING"
    msg = f"Error at Δt = {dt_coarse:,}s exceeds 5.0%"
    rec = f"Should refine timestep further. Consider Δt < {dt_coarse:,}s."

print(f"{status}: {msg}")
print(f"  → {rec}")

print(f"\nExpected convergence order for RK4: O(Δt⁴)")
print(f"Observed convergence orders (semi-major axis):")
for i in range(1, len(sorted_dts)):
    dt_prev = sorted_dts[i-1]
    dt_curr = sorted_dts[i]
    err_prev = error_data[dt_prev]['a']
    err_curr = error_data[dt_curr]['a']
    if err_prev > 1e-6 and err_curr > 1e-6:
        order = np.log(err_prev / err_curr) / np.log(dt_prev / dt_curr)
        print(f"  Δt = {dt_prev:,}s → {dt_curr:,}s: {order:.2f}")

print(f"\n{'='*70}\n")
